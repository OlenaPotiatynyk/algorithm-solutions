# ðŸ“š Algorithm Practice Project

Welcome to the **Algorithm Practice Project**! This repository is a curated collection of coding challenges categorized by algorithmic strategy. It's designed to help reinforce algorithmic thinking and prepare for technical interviews.

---

## ðŸ”– Categories of Algorithms

### 1. Greedy

* Always makes the optimal choice at each step.
* Example problems:

    * [121. Best Time to Buy and Sell Stock](./greedy/best-time-to-buy-sell-stock.js)
    * [122. Best Time to Buy and Sell Stock II](./greedy/best-time-to-buy-sell-stock-ii.js)
    * ~~[134. Gas Station](./greedy/gas-station.js)~~
    * [2037. Minimum Number of Moves to Seat Everyone](./greedy/2037-minimum-number-of-moves-to-seat-everyone.js)

### 2. Two Pointers

* Used for iterating over an array from both ends or in tandem.
* Example problems:

    * ~~[977. Squares of a Sorted Array](./two-pointers/squares-of-sorted-array.js)~~
    * ~~[167. Two Sum II - Input array is sorted](./two-pointers/two-sum-ii.js)~~

### 3. Sliding Window

* Maintains a window to avoid recomputation.
* Example problems:

    * ~~[3. Longest Substring Without Repeating Characters](./sliding-window/longest-substring-no-repeat.js)~~
    * ~~[567. Permutation in String](./sliding-window/permutation-in-string.js)~~

### 4. Hash Map / Set

* Efficient storage and lookup.
* Example problems:

    * ~~[1. Two Sum](./hashmap/two-sum.js)~~
    * ~~[128. Longest Consecutive Sequence](./hashmap/longest-consecutive.js)~~

### 5. Sorting

* Often paired with greedy or binary search.
* Example problems:

    * ~~[56. Merge Intervals](./sorting/merge-intervals.js)~~
    * ~~[88. Merge Sorted Array](./sorting/merge-sorted-array.js)~~

### 6. Binary Search

* Efficient search in sorted data or answer range.
* Example problems:

    * ~~[704. Binary Search](./binary-search/binary-search.js)~~
    * ~~[875. Koko Eating Bananas](./binary-search/koko-bananas.js)~~

### 7. Backtracking

* Explore all possible solutions with pruning.
* Example problems:

    * ~~[46. Permutations](./backtracking/permutations.js)~~
    * ~~[78. Subsets](./backtracking/subsets.js)~~

### 8. Dynamic Programming

* Solve subproblems and build up.
* Example problems:

    * ~~[198. House Robber](./dp/house-robber.js)~~
    * ~~[322. Coin Change](./dp/coin-change.js)~~

### 9. Graph Algorithms

* BFS/DFS traversal and more.
* Example problems:

    * ~~[200. Number of Islands](./graph/number-of-islands.js)~~
    * ~~[133. Clone Graph](./graph/clone-graph.js)~~

### 10. Tree Algorithms

* Specialized traversal and structure-based logic.
* Example problems:

    * ~~[104. Maximum Depth of Binary Tree](./tree/max-depth.js)~~
    * ~~[226. Invert Binary Tree](./tree/invert-tree.js)~~

### 11. Bit Manipulation

* Operate directly on bits.
* Example problems:

    * ~~[136. Single Number](./bit/single-number.js)~~
    * ~~[190. Reverse Bits](./bit/reverse-bits.js)~~

### 12. Math

* Leverages number theory or combinatorics.
* Example problems:

    * ~~[7. Reverse Integer](./math/reverse-integer.js)~~
    * ~~[1689. Partitioning Into Minimum Number of Deci-Binary Numbers](./math/min-deci-binary.js)~~

### 13. Heap / Priority Queue

* Maintain dynamic ordering.
* Example problems:

    * ~~[215. Kth Largest Element in an Array](./heap/kth-largest.js)~~
    * ~~[621. Task Scheduler](./heap/task-scheduler.js)~~

### 14. Union-Find / DSU

* Efficient merging and grouping.
* Example problems:

    * ~~[547. Number of Provinces](./dsu/number-of-provinces.js)~~
    * ~~[684. Redundant Connection](./dsu/redundant-connection.js)~~

### 15. Trie

* Efficient prefix search.
* Example problems:

    * ~~[208. Implement Trie (Prefix Tree)](./trie/implement-trie.js)~~
    * ~~[211. Design Add and Search Words Data Structure](./trie/search-words.js)~~

---

## ðŸ—‚ How to Use

* Each folder contains `.js` files with problem statements and solutions.
* Run them with Node.js or integrate into your learning platform.
* Fork this repo, and add your own notes or variants.

## ðŸ§  Contribution

Youâ€™re encouraged to:

* Add more problems.
* Improve existing solutions.
* Share insights and patterns youâ€™ve discovered.

---

Happy coding! ðŸš€
